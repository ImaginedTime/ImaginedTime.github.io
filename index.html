<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>uday0 · Orb Collector</title>
		<style>
			:root {
				--bg: #0f1724;
				--card: #0b1220;
				--accent: #4ade80;
				--muted: #94a3b8;
			}
			html,
			body {
				height: 100%;
				margin: 0;
				font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto,
					"Helvetica Neue", Arial;
			}
			body {
				background: linear-gradient(180deg, #071020 0%, var(--bg) 100%);
				display: flex;
				align-items: center;
				justify-content: center;
				color: #e6eef6;
			}
			.wrap {
				width: min(980px, 95vw);
				background: linear-gradient(
					180deg,
					rgba(255, 255, 255, 0.02),
					transparent
				);
				border: 1px solid rgba(255, 255, 255, 0.03);
				border-radius: 14px;
				padding: 18px;
				box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
			}
			header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 12px;
			}
			h1 {
				font-size: 18px;
				margin: 0;
			}
			.controls {
				display: flex;
				gap: 8px;
				align-items: center;
			}
			button {
				background: transparent;
				border: 1px solid rgba(255, 255, 255, 0.06);
				color: inherit;
				padding: 8px 10px;
				border-radius: 8px;
				cursor: pointer;
			}
			button.primary {
				background: var(--accent);
				color: #022c10;
				border: none;
			}
			.game-area {
				display: flex;
				gap: 12px;
				align-items: flex-start;
			}
			#game {
				background: linear-gradient(
					180deg,
					rgba(255, 255, 255, 0.02),
					transparent
				);
				border-radius: 10px;
				border: 1px solid rgba(255, 255, 255, 0.03);
			}
			.sidebar {
				width: 240px;
			}
			.panel {
				background: rgba(255, 255, 255, 0.02);
				padding: 12px;
				border-radius: 10px;
				border: 1px solid rgba(255, 255, 255, 0.02);
				margin-bottom: 12px;
			}
			.muted {
				color: var(--muted);
				font-size: 13px;
			}
			.big {
				font-size: 28px;
				font-weight: 700;
			}
			footer {
				margin-top: 10px;
				font-size: 13px;
				color: var(--muted);
			}
			@media (max-width: 760px) {
				.game-area {
					flex-direction: column;
				}
				.sidebar {
					width: 100%;
				}
			}
			/* small hint bubble */
			.hint {
				font-size: 13px;
				color: var(--muted);
				margin-top: 6px;
			}
		</style>
	</head>
	<body>
		<div class="wrap">
			<header>
				<h1>Orb Collector — play in your browser</h1>
				<div class="controls">
					<button id="btn-start" class="primary">Start</button>
					<button id="btn-reset">Reset</button>
				</div>
			</header>

			<div class="game-area">
				<canvas id="game" width="720" height="480"></canvas>

				<div class="sidebar">
					<div class="panel">
						<div class="muted">Score</div>
						<div id="score" class="big">0</div>
						<div class="muted">Level</div>
						<div id="level" class="big">1</div>
					</div>

					<div class="panel">
						<div class="muted">How to play</div>
						<ul class="muted">
							<li>Move with mouse / touch.</li>
							<li>Collect green orbs for points.</li>
							<li>Avoid red foes — they damage you.</li>
							<li>
								Survive long enough to level up; difficulty
								increases.
							</li>
						</ul>
						<div class="hint">
							Tip: move in short bursts to lure enemies into
							collectibles.
						</div>
					</div>

					<div class="panel">
						<div class="muted">Best session</div>
						<div id="best" class="big">0</div>
					</div>
				</div>
			</div>

			<footer class="muted">
				A tiny game served as a single file — drop
				<code>index.html</code> into your repo root to publish.
			</footer>
		</div>

		<script>
			// --- simple arcade: player collects orbs, avoids enemies ---
			const canvas = document.getElementById("game");
			const ctx = canvas.getContext("2d");
			let W = canvas.width,
				H = canvas.height;

			// DOM
			const scoreEl = document.getElementById("score");
			const levelEl = document.getElementById("level");
			const bestEl = document.getElementById("best");
			const btnStart = document.getElementById("btn-start");
			const btnReset = document.getElementById("btn-reset");

			// state
			let running = false;
			let score = 0,
				level = 1,
				best = Number(localStorage.getItem("ut_best") || 0);
			bestEl.textContent = best;

			// player
			const player = {
				x: W / 2,
				y: H / 2,
				r: 12,
				speed: 3,
				hp: 3,
				inv: 0,
			};
			let keys = {};

			// entities
			let orbs = [],
				foes = [];
			let tick = 0;

			function rand(min, max) {
				return Math.random() * (max - min) + min;
			}

			function spawnOrb() {
				orbs.push({
					x: rand(24, W - 24),
					y: rand(24, H - 24),
					r: 8,
					age: 0,
				});
			}
			function spawnFoe() {
				// spawn at edge
				let side = Math.floor(rand(0, 4));
				let x, y;
				if (side === 0) {
					x = -20;
					y = rand(0, H);
				} else if (side === 1) {
					x = W + 20;
					y = rand(0, H);
				} else if (side === 2) {
					x = rand(0, W);
					y = -20;
				} else {
					x = rand(0, W);
					y = H + 20;
				}
				foes.push({ x, y, r: 14, vx: 0, vy: 0, spd: 1 + level * 0.35 });
			}

			function reset() {
				score = 0;
				level = 1;
				player.x = W / 2;
				player.y = H / 2;
				player.hp = 3;
				orbs = [];
				foes = [];
				tick = 0;
				running = false;
				updateHUD();
			}

			function start() {
				if (!running) {
					running = true;
					btnStart.textContent = "Pause";
				} else {
					running = false;
					btnStart.textContent = "Start";
				}
			}

			function updateHUD() {
				scoreEl.textContent = score;
				levelEl.textContent = level;
				bestEl.textContent = best;
			}

			function distance(a, b) {
				let dx = a.x - b.x,
					dy = a.y - b.y;
				return Math.sqrt(dx * dx + dy * dy);
			}

			// input
			window.addEventListener("keydown", (e) => (keys[e.key] = true));
			window.addEventListener("keyup", (e) => (keys[e.key] = false));
			canvas.addEventListener("mousemove", (e) => {
				const rect = canvas.getBoundingClientRect();
				const mx =
					(e.clientX - rect.left) * (canvas.width / rect.width);
				const my =
					(e.clientY - rect.top) * (canvas.height / rect.height);
				player.targetX = mx;
				player.targetY = my;
			});
			canvas.addEventListener(
				"touchmove",
				(e) => {
					e.preventDefault();
					const t = e.touches[0];
					const rect = canvas.getBoundingClientRect();
					const mx =
						(t.clientX - rect.left) * (canvas.width / rect.width);
					const my =
						(t.clientY - rect.top) * (canvas.height / rect.height);
					player.targetX = mx;
					player.targetY = my;
				},
				{ passive: false }
			);

			// resize support
			function fitCanvas() {
				const ratio = Math.min(960, window.innerWidth * 0.7);
				// keep fixed canvas internal size, but scale via CSS for crispness
			}

			// main loop
			function step() {
				if (running) {
					tick++;
					// spawn orbs and foes over time
					if (tick % 90 === 0) spawnOrb();
					if (tick % 160 === 0) spawnFoe();
					// difficulty bumps
					if (
						score > 0 &&
						score % 7 === 0 &&
						level < Math.floor(score / 7) + 1
					)
						level = Math.floor(score / 7) + 1;

					// move player
					let dx = 0,
						dy = 0;
					const s = player.speed + (level - 1) * 0.2;
					if (keys["ArrowLeft"] || keys["a"]) dx -= 1;
					if (keys["ArrowRight"] || keys["d"]) dx += 1;
					if (keys["ArrowUp"] || keys["w"]) dy -= 1;
					if (keys["ArrowDown"] || keys["s"]) dy += 1;
					if (player.targetX !== undefined) {
						let tx = player.targetX,
							ty = player.targetY;
						dx += (tx - player.x) / 50;
						dy += (ty - player.y) / 50;
					}
					// normalize
					const mag = Math.sqrt(dx * dx + dy * dy) || 1;
					player.x += (dx / mag) * s;
					player.y += (dy / mag) * s;
					player.x = Math.max(10, Math.min(W - 10, player.x));
					player.y = Math.max(10, Math.min(H - 10, player.y));

					// orbs aging and collision
					for (let i = orbs.length - 1; i >= 0; i--) {
						const o = orbs[i];
						o.age++;
						if (distance(player, o) < player.r + o.r) {
							score += 1;
							orbs.splice(i, 1);
							if (score > best) {
								best = score;
								localStorage.setItem("ut_best", best);
							}
						} else if (o.age > 800) orbs.splice(i, 1);
					}

					// foes movement (homing)
					for (let i = foes.length - 1; i >= 0; i--) {
						const f = foes[i];
						const ang = Math.atan2(player.y - f.y, player.x - f.x);
						f.vx += Math.cos(ang) * 0.06;
						f.vy += Math.sin(ang) * 0.06;
						// friction and clamp
						f.vx *= 0.98;
						f.vy *= 0.98;
						const spd = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
						const maxspd = f.spd + (level - 1) * 0.2;
						if (spd > maxspd) {
							f.vx = (f.vx / spd) * maxspd;
							f.vy = (f.vy / spd) * maxspd;
						}
						f.x += f.vx;
						f.y += f.vy;
						// collision with player
						if (distance(player, f) < player.r + f.r) {
							// take damage if not recently invincible
							if (player.inv <= 0) {
								player.hp -= 1;
								player.inv = 50;
							}
						}
						// remove offscreen long living foes
						if (
							f.x < -60 ||
							f.x > W + 60 ||
							f.y < -60 ||
							f.y > H + 60
						)
							foes.splice(i, 1);
					}

					if (player.inv > 0) player.inv--;
					// game over
					if (player.hp <= 0) {
						running = false;
						btnStart.textContent = "Start";
						if (score > best) {
							best = score;
							localStorage.setItem("ut_best", best);
						}
					}
				}
				draw();
				requestAnimationFrame(step);
			}

			function draw() {
				// clear
				ctx.clearRect(0, 0, W, H);
				// background grid
				ctx.fillStyle = "rgba(255,255,255,0.02)";
				ctx.fillRect(0, 0, W, H);

				// draw orbs
				for (const o of orbs) {
					ctx.beginPath();
					ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
					ctx.fillStyle = "rgba(74,222,128,0.95)";
					ctx.fill();
					ctx.lineWidth = 2;
					ctx.strokeStyle = "rgba(255,255,255,0.06)";
					ctx.stroke();
				}

				// draw foes
				for (const f of foes) {
					ctx.beginPath();
					ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
					ctx.fillStyle = "rgba(248,113,113,0.95)";
					ctx.fill();
					ctx.lineWidth = 2;
					ctx.strokeStyle = "rgba(255,255,255,0.03)";
					ctx.stroke();
				}

				// player
				ctx.save();
				if (player.inv > 0) ctx.globalAlpha = 0.6;
				ctx.beginPath();
				ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
				ctx.fillStyle = "rgba(96,165,250,0.95)";
				ctx.fill();
				ctx.lineWidth = 3;
				ctx.strokeStyle = "rgba(255,255,255,0.08)";
				ctx.stroke();
				ctx.restore();

				// hp bar
				for (let i = 0; i < 3; i++) {
					ctx.beginPath();
					ctx.rect(12 + i * 22, H - 28, 16, 8);
					ctx.fillStyle =
						i < player.hp
							? "rgba(74,222,128,0.95)"
							: "rgba(255,255,255,0.04)";
					ctx.fill();
					ctx.strokeStyle = "rgba(255,255,255,0.05)";
					ctx.stroke();
				}

				// info overlay
				ctx.fillStyle = "rgba(0,0,0,0.25)";
				ctx.fillRect(W - 150, 10, 140, 46);
				ctx.fillStyle = "rgba(255,255,255,0.85)";
				ctx.font = "14px system-ui";
				ctx.fillText("Score: " + score, W - 140, 30);
				ctx.fillText("Level: " + level, W - 140, 46);

				// paused / game over text
				if (!running && player.hp > 0) {
					ctx.fillStyle = "rgba(255,255,255,0.06)";
					ctx.fillRect(W / 2 - 160, H / 2 - 60, 320, 120);
					ctx.fillStyle = "#e6eef6";
					ctx.font = "18px system-ui";
					ctx.textAlign = "center";
					ctx.fillText("Click START to play", W / 2, H / 2 - 6);
					ctx.font = "13px system-ui";
					ctx.fillStyle = "rgba(255,255,255,0.7)";
					ctx.fillText(
						"Collect orbs, avoid foes. Use mouse/arrow keys.",
						W / 2,
						H / 2 + 18
					);
					ctx.textAlign = "start";
				}
				if (player.hp <= 0) {
					ctx.fillStyle = "rgba(0,0,0,0.45)";
					ctx.fillRect(W / 2 - 160, H / 2 - 60, 320, 120);
					ctx.fillStyle = "#fff";
					ctx.font = "22px system-ui";
					ctx.textAlign = "center";
					ctx.fillText("Game Over", W / 2, H / 2 - 6);
					ctx.font = "14px system-ui";
					ctx.fillText("Your score: " + score, W / 2, H / 2 + 20);
					ctx.textAlign = "start";
				}
			}

			// UI wiring
			btnStart.addEventListener("click", () => {
				start();
			});
			btnReset.addEventListener("click", () => {
				reset();
				updateHUD();
			});

			// initial spawns
			for (let i = 0; i < 3; i++) spawnOrb();

			// make canvas scale nicely on HiDPI displays
			function scaleCanvas() {
				const dpr = window.devicePixelRatio || 1;
				const cssW = Math.min(
					720,
					Math.floor(window.innerWidth * 0.64)
				);
				const cssH = Math.round(cssW * (480 / 720));
				canvas.style.width = cssW + "px";
				canvas.style.height = cssH + "px";
				canvas.width = Math.floor(cssW * dpr);
				canvas.height = Math.floor(cssH * dpr);
				W = canvas.width;
				H = canvas.height;
				// keep player inside
				player.x = Math.max(10, Math.min(W - 10, player.x));
				player.y = Math.max(10, Math.min(H - 10, player.y));
			}
			window.addEventListener("resize", () => {
				scaleCanvas();
				draw();
			});
			scaleCanvas();
			draw();
			requestAnimationFrame(step);
		</script>
	</body>
</html>
